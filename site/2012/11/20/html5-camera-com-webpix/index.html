<!doctype html>
<html lang="pt-BR">

<head>
	<meta charset="UTF-8" />
	
		<title>HTML5 câmera com WebPix | Open Blog</title>
	
	
		<meta name="author" content="Caio Gondim" />
	
	
		<meta name="keywords" content="camera, getusermedia, api, javascript, html5, video, canvas, browser, navegador
" />
	
	
		<meta name="description" content="Hoje vamos falar de coisa boa. Vamos falar de como usar sua câmera apenas com HTML5. E para mostrar isso na prática de um jeito menos chato, fizemos um pequeno experimento para ensinar melhor como funciona essa nova API de acesso à câmera do seu computador através do navegador." />
	
	<meta name="language" content="pt" />
	<meta name="content-language" content="pt-BR" />
	<meta name="robots" content="all" />
	<meta name="distribution" content="Global" />
	<meta name="resource-type" content="document" />

	<link rel="icon" type="image/png" href="/assets/img/favicon.png" />
    <link href="/assets/css/screen.css?2013-02-22" media="screen, projection" rel="stylesheet" type="text/css" />
    <!--[if IE]>
    	<link href="/assets/css/ie.css?2013-02-22" media="screen, projection" rel="stylesheet" type="text/css" />
  	<![endif]-->
	<link href='http://fonts.googleapis.com/css?family=Ubuntu:300' rel='stylesheet' type='text/css'>
</head>

<body>

	<div id="wrapper">
		
		<header id="main">
	<h1><a href="/" id="logo">.openBlog()</a></h1>
</header>
		
		<section id="content">

			<section class="post-container" itemscope itemtype="http://schema.org/BlogPosting">
				<span class="hidden" itemprop="publisher">Open Blog</span>
				<article>
					<header>
						<h1><a href="/2012/11/20/html5-camera-com-webpix/" itemprop="headline">HTML5 câmera com WebPix</a></h1>
					</header>
					<section itemprop="articleBody">
						
						<style>
	iframe {
		width: 700px;
		height: 432px;
	}
</style><iframe class='img' frameborder='0' src='http://caiogondim.github.com/webpix'> </iframe>
<p>Hoje vamos falar de coisa boa. Vamos falar de <span style='text-decoration: line-through;'>TekPix</span> como usar sua câmera apenas com HTML5. E para mostrar isso na prática de um jeito menos chato, fizemos um pequeno experimento para ensinar melhor como funciona essa nova API de acesso à câmera do seu computador através do navegador.</p>
<p class='obs'><strong>OBS.:</strong> O experimento deste post foi
testado na versão <strong>25.0 dev do Chrome para Mac</strong>. No
<strong>Firefox 17.0 para Mac</strong>, mesmo
ele informando que suporta a API <strong>getUserMedia()</strong> com o prefixo
 <strong>moz</strong>, não consegui fazer rodar o experimento e também
não achei nenhum experimento na web que rodasse nele.</p>
<h2 id='a_cmera_mais_popular_da_web'>A câmera mais popular da web</h2>

<p>Antes de começarmos a falar mais tecnicamente sobre o experimento, vamos primeiro brincar com ele para então entendermos como foi feito. Esta imagem que você vê ai em cima é na verdade o próprio experimento. Para começar a brincar com ele, primeiro libere o acesso à câmera do seu computador. Deve ter aparecido uma barra embaixo da barra de endereço (caso você esteja no Chrome) perguntando se você permite ou não o acesso a câmera. Libere o acesso para começar a tirar algumas fotos de qualidade com esta fantástica câmera.</p>
<figure>
    <img alt='Palestrantes' height='200' src='/images/posts/2012-11-20-permissao-camera.jpg' title='Palestrantes' width='700' />
</figure>
<p>Depois de ter liberado o acesso, você provavelmente deve estar se vendo na tela de <strong>altíssima</strong> resolução da WebPix. Ótimo. Agora é só fazer um <a href='http://www.rubberduckface.com/mona-duck-face-lisa/'>duck face</a> e apertar o ícone da câmera para tirar uma foto.</p>

<p>Com a sua bela imagem no <em>display</em> da WebPix, você pode <em>instagramizar</em> suas fotos apertando nos botões de efeito e, quando ficar satisfeito, pode fazer o download da foto. Ou então descartá-la apertando o botão com ícone de lixeira e tentar novamente.</p>

<h2 id='vamos_falar_de_webpix'>Vamos falar de WebPix</h2>

<p>Já sabendo como brincar com a WebPix, vamos ver como ela funciona. A primeira coisa que temos que fazer é pedir ao usuário permissão para usar a câmera.</p>
<div class='highlight'><pre><code class='javascript'><span class='nx'>navigator</span><span class='p'>.</span><span class='nx'>webkitGetUserMedia</span><span class='p'>(</span> <span class='p'>{</span> <span class='nx'>video</span><span class='o'>:</span> <span class='kc'>true</span> <span class='p'>},</span> <span class='nx'>sucessoCallback</span><span class='p'>,</span> <span class='nx'>falhaCallback</span> <span class='p'>)</span>
</code></pre></div>
<p>Esta função recebe 3 argumentos:</p>

<ul>
<li><strong>constraints</strong>: um objeto com, no momento, 2 valores de chave possíveis. <strong>video</strong> e <strong>audio</strong>. Informa quais dispositivos queremos utilizar. Para usar microfone e câmera, basta passar <code>{ audio: true, video: true }</code>.</li>

<li><strong>callback de sucesso</strong>: função disparada caso o usuário libere o acesso aos dispositivos. Recebe um objeto do tipo <code>stream</code> com o fluxo de dados do microfone e/ou câmera.</li>

<li><strong>callback de falha</strong>: função disparada caso o usuário não libere o acesso aos dispositivos.</li>
</ul>
<p class='obs'><strong>OBS.:</strong> Não esqueçam que, em uma aplicação real, nós
devemos sempre testar se o navegador nos dá suporte a API que queremos usar.
Para não tornar o exemplo mais complexo, não vamos testar o suporte.</p>
<p>Quando o usuário liberar o acesso, a função de callback de sucesso irá disparar. Com acesso à câmera, agora vamos direcionar o <em>stream</em> da câmera para um elemento <code>video</code>.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>function</span> <span class='nx'>sucessoCallback</span><span class='p'>(</span> <span class='nx'>stream</span> <span class='p'>)</span> <span class='p'>{</span>
  <span class='kd'>var</span> <span class='nx'>video</span> <span class='o'>=</span> <span class='nb'>document</span><span class='p'>.</span><span class='nx'>querySelector</span><span class='p'>(</span> <span class='s1'>&#39;video&#39;</span> <span class='p'>)</span>
  <span class='nx'>video</span><span class='p'>.</span><span class='nx'>src</span> <span class='o'>=</span> <span class='nb'>window</span><span class='p'>.</span><span class='nx'>webkitURL</span><span class='p'>.</span><span class='nx'>createObjectURL</span><span class='p'>(</span> <span class='nx'>stream</span> <span class='p'>)</span>
  <span class='nx'>video</span><span class='p'>.</span><span class='nx'>play</span><span class='p'>()</span>
<span class='p'>}</span>
</code></pre></div>
<p>Imaginem que já temos uma <em>tag</em>&#160;<code>video</code> em nosso HTML. No código acima estamos apenas setando o <code>src</code> da <em>tag</em>&#160;<code>video</code> como sendo o <em>stream</em> da nossa câmera e logo depois executamos o método <code>play</code> para que ele mostre o que a câmera está capturando. Acabamos de codificar um espelho. Simples, ok?</p>

<h2 id='e_se_voc_ligar_agora'>E se você ligar agora&#8230;</h2>

<p>Fazer uma aplicação &#8220;espelho&#8221; é bem fácil. Mas como capturar os dados vindos da câmera e manipular esses dados da forma que quisermos? Para isso vamos usar o <code>canvas</code>.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>canvas</span> <span class='o'>=</span> <span class='nb'>document</span><span class='p'>.</span><span class='nx'>querySelector</span><span class='p'>(</span> <span class='s1'>&#39;canvas&#39;</span> <span class='p'>)</span>
<span class='nx'>canvas</span><span class='p'>.</span><span class='nx'>width</span> <span class='o'>=</span> <span class='nx'>video</span><span class='p'>.</span><span class='nx'>videoWidth</span>
<span class='nx'>canvas</span><span class='p'>.</span><span class='nx'>height</span> <span class='o'>=</span> <span class='nx'>video</span><span class='p'>.</span><span class='nx'>videoHeight</span>
<span class='kd'>var</span> <span class='nx'>ctx</span> <span class='o'>=</span> <span class='nx'>canvas</span><span class='p'>.</span><span class='nx'>getContext</span><span class='p'>(</span> <span class='s1'>&#39;2d&#39;</span> <span class='p'>)</span>
<span class='kd'>var</span> <span class='nx'>ctx</span><span class='p'>.</span><span class='nx'>drawImage</span><span class='p'>(</span> <span class='nx'>video</span><span class='p'>,</span> <span class='mi'>0</span><span class='p'>,</span> <span class='mi'>0</span> <span class='p'>)</span>
</code></pre></div>
<p>No código acima capturamos a referência ao elemento <code>canvas</code> definido em nosso HTML, setamos sua altura e largura com sendo iguais ao do vídeo, setamos o contexto do <code>canvas</code> como 2D (o único contexto até o momento implementado) e desenhamos uma imagem no canvas, sendo esta imagem um <em>frame</em> da <em>tag</em>&#160;<code>video</code>.</p>

<p>Não é possível modificar diretamente o <em>stream</em> da câmera, já que não temos acesso binário a ela. Mas, a partir do momento que a imagem está no <code>canvas</code>, nós temos acesso a nível de pixel.</p>

<p>No momento que o botão <strong>tirar foto</strong> é clicado, nós capturamos um <em>frame</em> do vídeo, jogamos no <code>canvas</code> e, depois disso, jogamos o que está no <code>canvas</code> para uma <em>tag</em>&#160;<code>img</code> que estava anteriormente escondida. Então quando você acha que está vendo o vídeo pausado, aquilo é na verdade uma <code>img</code> com o <code>src</code> de um frame da <em>tag</em>&#160;<code>video</code>.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>img</span> <span class='o'>=</span> <span class='nb'>document</span><span class='p'>.</span><span class='nx'>querySelector</span><span class='p'>(</span> <span class='s1'>&#39;img&#39;</span> <span class='p'>)</span>
<span class='nx'>img</span><span class='p'>.</span><span class='nx'>src</span> <span class='o'>=</span> <span class='nx'>canvas</span><span class='p'>.</span><span class='nx'>toDataURL</span><span class='p'>(</span><span class='s1'>&#39;image/png&#39;</span><span class='p'>)</span>
</code></pre></div>
<p>Poderíamos obter o mesmo efeito apenas chamando o método <code>pause()</code> da <em>tag</em>&#160;<code>video</code>, mas já vamos explicar porque precisamos dessa imagem escondida.</p>

<p>Como agora temos o nosso <em>frame</em> no <code>canvas</code>, podemos manipular a imagem e aplicar alguns filtros a lá <strong>Instagram</strong>. Como o foco do post é a API de acesso a câmera, não vou falar a respeito de filtro de imagens com o <code>canvas</code>. Mas para quem quiser se aprofundar no assunto aconselho o <a href='http://www.html5rocks.com/en/tutorials/canvas/imagefilters/'>excelente artigo</a> do <a href='https://twitter.com/ilmarihei'>Ilmari Heikinnen</a> no <a href='http://www.html5rocks.com/en/'>HTML5 Rocks</a>.</p>

<h2 id='e_no__s_isso'>E não é só isso</h2>

<p>Neste experimento também é possível fazer o download da sua foto. Você deve estar se perguntando: <em>&#8220;E daí?&#8221;</em>. O diferencial aqui é que este download está acontecendo sem <strong>nenhum back-end</strong>. Ou seja, esta imagem que você esta fazendo download está sendo gerada e disponibilizada diretamente pelo navegador.</p>

<p>Com o novo atributo <code>download</code>, nós informamos ao navegador que não queremos visitar aquele link, e sim fazer o <em>download</em> daquele <em>link</em>.</p>
<div class='highlight'><pre><code class='html'><span class='nt'>&lt;a</span> <span class='na'>download=</span><span class='s'>&quot;minha-foto-na-webpix.png&quot;</span> <span class='na'>href=</span><span class='s'>&quot;#&quot;</span> <span class='na'>class=</span><span class='s'>&quot;download&quot;</span><span class='nt'>&gt;</span> <span class='nt'>&lt;/a&gt;</span>
</code></pre></div>
<p>E toda vez que a foto é modificada, nós dinamicamente setamos o <code>href</code> da <em>tag</em>&#160;<code>a</code> que acabamos de ver.</p>
<div class='highlight'><pre><code class='javascript'><span class='kd'>var</span> <span class='nx'>downloadLink</span> <span class='o'>=</span> <span class='nb'>document</span><span class='p'>.</span><span class='nx'>querySelector</span><span class='p'>(</span> <span class='s1'>&#39;.download&#39;</span> <span class='p'>)</span>
<span class='nx'>downloadLink</span><span class='p'>.</span><span class='nx'>href</span> <span class='o'>=</span> <span class='nx'>canvas</span><span class='p'>.</span><span class='nx'>toDataURL</span><span class='p'>(</span><span class='s1'>&#39;image/png&#39;</span><span class='p'>)</span>
</code></pre></div>
<p>O que está acontecendo no trecho acima é que setamos o <code>href</code> do <em>link</em> como sendo o que está no <code>canvas</code>. Fazemos isso transformando o que está desenhado no <code>canvas</code> para DataURL e setando essa URL como <code>href</code> do link.</p>

<h2 id='compre_agora'>Compre agora</h2>

<p>Esse foi o WebPix. Um pequeno experimento que fizemos para apresentar a vocês a API de acesso à câmera. Procurei ser o mais didático possível neste post, mas se você quiser saber até onde vai a toca do coelho, todo o codigo está disponível no <a href='https://github.com/caiogondim/webpix'>GitHub</a>.</p>
<table class='support'>
    <thead>
        <tr>
            <th class='subject'><h2>Suporte</h2></th>
            <th class='browser chrome'><div class='i' /></th>
            <th class='browser safari'><div class='i' /></th>
            <th class='browser firefox'><div class='i' /></th>
            <th class='browser ie'><div class='i' /></th>
            <th class='browser opera'><div class='i' /></th>
        </tr>
        <tr>
            <th />
            <th class='base' colspan='5' />
        </tr>
    </thead>
    <tbody>
        <tr>
            <td class='property'><code>navigator.getUserMedia</code></td>
            <td>22.0</td>
            <td>--</td>
            <td>--</td>
            <td>--</td>
            <td>12.0</td>
        </tr>
    </tbody>
</table>
<p>O suporte a esta API ainda não está presente em todos os <em>browsers</em> e mesmo nos que já apresentam o objeto <code>navigator.getUserMedia</code>, como no Firefox, ela simplesmente não funciona. Mas com certeza não vai demorar muito para que todos os navegadores a implemente de forma confiável.</p>

<p>E se tiverem qualquer dúvida ou melhoria a respeito do experimento, vamos bater um papo aqui nos comentários.</p>
<aside class='fonte'>
    <h3>Referência</h3>
    <ul>
        <li>→<a alt='Image Filters' href='http://www.html5rocks.com/en/tutorials/canvas/imagefilters/' title='Image Filters'>Image Filters</a> <span class='comment'>// HTML5 Rocks</span></li>
        <li>→<a alt='Playing with HTML5 video &amp; getUserMedia support' href='http://dev.opera.com/articles/view/playing-with-html5-video-and-getusermedia-support/' title='Playing with HTML5 video &amp; getUserMedia support'>Playing with HTML5 video &amp; getUserMedia support</a> <span class='comment'>// Dev.Opera</span></li>
    </ul>
</aside>
					</section>
				</article>
			</section>

		</section><!-- end #content -->

	</div><!-- end #wrapper -->

</body>
</html>
